/**
 * ESM Platform - Load Testing Utilities
 * Comprehensive load testing for 300+ concurrent users validation
 */

const http = require('http');\nconst https = require('https');\nconst { performance } = require('perf_hooks');\nconst fs = require('fs');\nconst path = require('path');\n\n// ============================================\n// LOAD TESTING CONFIGURATION\n// ============================================\n\nconst CONFIG = {\n  // Base configuration\n  baseUrl: process.env.LOAD_TEST_URL || 'http://localhost:3000',\n  maxConcurrentUsers: parseInt(process.env.MAX_CONCURRENT_USERS) || 300,\n  testDuration: parseInt(process.env.TEST_DURATION) || 300000, // 5 minutes\n  rampUpTime: parseInt(process.env.RAMP_UP_TIME) || 60000,     // 1 minute\n  \n  // Performance thresholds\n  thresholds: {\n    responseTime: {\n      p95: 2000,  // 95th percentile < 2 seconds\n      p99: 5000,  // 99th percentile < 5 seconds\n      max: 10000  // Maximum < 10 seconds\n    },\n    errorRate: 0.05, // < 5% error rate\n    throughput: 50   // > 50 requests per second\n  },\n  \n  // Test scenarios\n  scenarios: [\n    { name: 'user_login', weight: 20, endpoint: '/api/auth/signin', method: 'POST' },\n    { name: 'get_users', weight: 30, endpoint: '/api/users', method: 'GET' },\n    { name: 'user_details', weight: 25, endpoint: '/api/users/:id', method: 'GET' },\n    { name: 'dashboard_data', weight: 15, endpoint: '/api/analytics', method: 'GET' },\n    { name: 'health_check', weight: 10, endpoint: '/api/monitoring/health', method: 'GET' }\n  ]\n};\n\n// ============================================\n// HTTP CLIENT WITH CONNECTION POOLING\n// ============================================\n\nclass LoadTestClient {\n  constructor(baseUrl, options = {}) {\n    this.baseUrl = baseUrl;\n    this.isHttps = baseUrl.startsWith('https');\n    this.client = this.isHttps ? https : http;\n    \n    // Configure connection pooling for high concurrency\n    this.agent = new (this.isHttps ? https.Agent : http.Agent)({\n      keepAlive: true,\n      keepAliveMsecs: 30000,\n      maxSockets: 50,\n      maxFreeSockets: 10,\n      timeout: 30000,\n      ...options\n    });\n  }\n  \n  async makeRequest(path, options = {}) {\n    const startTime = performance.now();\n    \n    return new Promise((resolve, reject) => {\n      const url = new URL(path, this.baseUrl);\n      \n      const requestOptions = {\n        hostname: url.hostname,\n        port: url.port || (this.isHttps ? 443 : 80),\n        path: url.pathname + url.search,\n        method: options.method || 'GET',\n        agent: this.agent,\n        timeout: options.timeout || 30000,\n        headers: {\n          'User-Agent': 'ESM-LoadTest/1.0',\n          'Accept': 'application/json',\n          'Connection': 'keep-alive',\n          ...options.headers\n        }\n      };\n      \n      if (options.body) {\n        requestOptions.headers['Content-Type'] = 'application/json';\n        requestOptions.headers['Content-Length'] = Buffer.byteLength(options.body);\n      }\n      \n      const req = this.client.request(requestOptions, (res) => {\n        const chunks = [];\n        \n        res.on('data', (chunk) => {\n          chunks.push(chunk);\n        });\n        \n        res.on('end', () => {\n          const endTime = performance.now();\n          const responseTime = endTime - startTime;\n          const body = Buffer.concat(chunks).toString();\n          \n          resolve({\n            statusCode: res.statusCode,\n            headers: res.headers,\n            body,\n            responseTime,\n            timestamp: startTime\n          });\n        });\n      });\n      \n      req.on('error', (error) => {\n        const endTime = performance.now();\n        const responseTime = endTime - startTime;\n        \n        reject({\n          error: error.message,\n          responseTime,\n          timestamp: startTime\n        });\n      });\n      \n      req.on('timeout', () => {\n        req.destroy();\n        const endTime = performance.now();\n        const responseTime = endTime - startTime;\n        \n        reject({\n          error: 'Request timeout',\n          responseTime,\n          timestamp: startTime\n        });\n      });\n      \n      if (options.body) {\n        req.write(options.body);\n      }\n      \n      req.end();\n    });\n  }\n  \n  destroy() {\n    this.agent.destroy();\n  }\n}\n\n// ============================================\n// VIRTUAL USER SIMULATOR\n// ============================================\n\nclass VirtualUser {\n  constructor(id, client, scenarios) {\n    this.id = id;\n    this.client = client;\n    this.scenarios = scenarios;\n    this.isActive = false;\n    this.requestCount = 0;\n    this.errorCount = 0;\n    this.responseTimes = [];\n    this.startTime = null;\n  }\n  \n  async start() {\n    this.isActive = true;\n    this.startTime = performance.now();\n    \n    while (this.isActive) {\n      try {\n        const scenario = this.selectScenario();\n        const result = await this.executeScenario(scenario);\n        \n        this.requestCount++;\n        this.responseTimes.push(result.responseTime);\n        \n        if (result.statusCode >= 400) {\n          this.errorCount++;\n        }\n        \n        // Random think time between requests (0.5-3 seconds)\n        const thinkTime = 500 + Math.random() * 2500;\n        await this.sleep(thinkTime);\n        \n      } catch (error) {\n        this.errorCount++;\n        console.error(`User ${this.id} error:`, error.error || error.message);\n        \n        // Back-off on error\n        await this.sleep(1000 + Math.random() * 2000);\n      }\n    }\n  }\n  \n  selectScenario() {\n    const random = Math.random() * 100;\n    let cumulative = 0;\n    \n    for (const scenario of this.scenarios) {\n      cumulative += scenario.weight;\n      if (random <= cumulative) {\n        return scenario;\n      }\n    }\n    \n    return this.scenarios[0]; // Fallback\n  }\n  \n  async executeScenario(scenario) {\n    let endpoint = scenario.endpoint;\n    \n    // Handle parameterized endpoints\n    if (endpoint.includes(':id')) {\n      endpoint = endpoint.replace(':id', Math.floor(Math.random() * 100) + 1);\n    }\n    \n    const options = {\n      method: scenario.method\n    };\n    \n    // Add request body for POST/PUT requests\n    if (scenario.method === 'POST' || scenario.method === 'PUT') {\n      if (scenario.name === 'user_login') {\n        options.body = JSON.stringify({\n          username: `testuser${this.id}`,\n          password: 'testpassword123'\n        });\n      }\n    }\n    \n    return await this.client.makeRequest(endpoint, options);\n  }\n  \n  async sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  \n  stop() {\n    this.isActive = false;\n  }\n  \n  getStats() {\n    const totalTime = this.startTime ? performance.now() - this.startTime : 0;\n    const avgResponseTime = this.responseTimes.length > 0 \n      ? this.responseTimes.reduce((a, b) => a + b, 0) / this.responseTimes.length \n      : 0;\n    \n    return {\n      id: this.id,\n      requestCount: this.requestCount,\n      errorCount: this.errorCount,\n      errorRate: this.requestCount > 0 ? this.errorCount / this.requestCount : 0,\n      avgResponseTime,\n      totalTime,\n      throughput: totalTime > 0 ? (this.requestCount / totalTime) * 1000 : 0\n    };\n  }\n}\n\n// ============================================\n// LOAD TEST COORDINATOR\n// ============================================\n\nclass LoadTestCoordinator {\n  constructor(config) {\n    this.config = config;\n    this.client = new LoadTestClient(config.baseUrl);\n    this.virtualUsers = [];\n    this.isRunning = false;\n    this.startTime = null;\n    this.results = {\n      totalRequests: 0,\n      totalErrors: 0,\n      responseTimes: [],\n      userStats: []\n    };\n  }\n  \n  async runLoadTest() {\n    console.log('🚀 Starting load test...');\n    console.log(`Target: ${this.config.baseUrl}`);\n    console.log(`Max Users: ${this.config.maxConcurrentUsers}`);\n    console.log(`Duration: ${this.config.testDuration / 1000}s`);\n    console.log(`Ramp-up: ${this.config.rampUpTime / 1000}s`);\n    \n    this.isRunning = true;\n    this.startTime = performance.now();\n    \n    // Start ramping up users\n    await this.rampUpUsers();\n    \n    // Run for specified duration\n    const remainingTime = this.config.testDuration - this.config.rampUpTime;\n    if (remainingTime > 0) {\n      console.log(`📊 Sustaining ${this.virtualUsers.length} users for ${remainingTime / 1000}s...`);\n      await this.sleep(remainingTime);\n    }\n    \n    // Stop all users\n    await this.stopAllUsers();\n    \n    // Collect and analyze results\n    const results = this.analyzeResults();\n    \n    // Generate report\n    this.generateReport(results);\n    \n    return results;\n  }\n  \n  async rampUpUsers() {\n    const usersPerSecond = this.config.maxConcurrentUsers / (this.config.rampUpTime / 1000);\n    const interval = 1000 / usersPerSecond;\n    \n    console.log(`📈 Ramping up ${usersPerSecond.toFixed(2)} users per second...`);\n    \n    for (let i = 0; i < this.config.maxConcurrentUsers && this.isRunning; i++) {\n      const user = new VirtualUser(i + 1, this.client, this.config.scenarios);\n      this.virtualUsers.push(user);\n      \n      // Start user in background\n      user.start().catch(error => {\n        console.error(`User ${user.id} crashed:`, error);\n      });\n      \n      // Wait for next user\n      if (i < this.config.maxConcurrentUsers - 1) {\n        await this.sleep(interval);\n      }\n      \n      // Progress update\n      if ((i + 1) % 50 === 0) {\n        console.log(`✨ ${i + 1}/${this.config.maxConcurrentUsers} users started`);\n      }\n    }\n    \n    console.log(`✅ All ${this.virtualUsers.length} users are active`);\n  }\n  \n  async stopAllUsers() {\n    console.log('🛑 Stopping all users...');\n    \n    this.virtualUsers.forEach(user => user.stop());\n    \n    // Wait a bit for users to finish their current requests\n    await this.sleep(5000);\n    \n    console.log('✅ All users stopped');\n  }\n  \n  analyzeResults() {\n    const endTime = performance.now();\n    const totalTime = endTime - this.startTime;\n    \n    // Collect stats from all users\n    const userStats = this.virtualUsers.map(user => user.getStats());\n    \n    // Aggregate metrics\n    const totalRequests = userStats.reduce((sum, stats) => sum + stats.requestCount, 0);\n    const totalErrors = userStats.reduce((sum, stats) => sum + stats.errorCount, 0);\n    const allResponseTimes = userStats.flatMap(stats => stats.responseTimes || []);\n    \n    // Calculate percentiles\n    const sortedTimes = allResponseTimes.sort((a, b) => a - b);\n    const p50 = this.percentile(sortedTimes, 0.5);\n    const p95 = this.percentile(sortedTimes, 0.95);\n    const p99 = this.percentile(sortedTimes, 0.99);\n    const max = sortedTimes[sortedTimes.length - 1] || 0;\n    const avg = sortedTimes.length > 0 ? sortedTimes.reduce((a, b) => a + b, 0) / sortedTimes.length : 0;\n    \n    const results = {\n      testConfig: this.config,\n      duration: totalTime,\n      totalUsers: this.virtualUsers.length,\n      totalRequests,\n      totalErrors,\n      errorRate: totalRequests > 0 ? totalErrors / totalRequests : 0,\n      throughput: (totalRequests / totalTime) * 1000, // requests per second\n      responseTime: {\n        avg,\n        p50,\n        p95,\n        p99,\n        max\n      },\n      userStats,\n      thresholdsPassed: {\n        responseTime: {\n          p95: p95 <= this.config.thresholds.responseTime.p95,\n          p99: p99 <= this.config.thresholds.responseTime.p99,\n          max: max <= this.config.thresholds.responseTime.max\n        },\n        errorRate: (totalRequests > 0 ? totalErrors / totalRequests : 0) <= this.config.thresholds.errorRate,\n        throughput: ((totalRequests / totalTime) * 1000) >= this.config.thresholds.throughput\n      }\n    };\n    \n    return results;\n  }\n  \n  percentile(sortedArray, percentile) {\n    if (sortedArray.length === 0) return 0;\n    const index = Math.ceil(sortedArray.length * percentile) - 1;\n    return sortedArray[Math.max(0, Math.min(index, sortedArray.length - 1))];\n  }\n  \n  generateReport(results) {\n    console.log('\\n📊 LOAD TEST RESULTS');\n    console.log('=' .repeat(50));\n    console.log(`Duration: ${(results.duration / 1000).toFixed(2)}s`);\n    console.log(`Users: ${results.totalUsers}`);\n    console.log(`Total Requests: ${results.totalRequests}`);\n    console.log(`Total Errors: ${results.totalErrors}`);\n    console.log(`Error Rate: ${(results.errorRate * 100).toFixed(2)}%`);\n    console.log(`Throughput: ${results.throughput.toFixed(2)} req/s`);\n    \n    console.log('\\n⏱️  RESPONSE TIMES');\n    console.log('-' .repeat(30));\n    console.log(`Average: ${results.responseTime.avg.toFixed(2)}ms`);\n    console.log(`50th Percentile: ${results.responseTime.p50.toFixed(2)}ms`);\n    console.log(`95th Percentile: ${results.responseTime.p95.toFixed(2)}ms`);\n    console.log(`99th Percentile: ${results.responseTime.p99.toFixed(2)}ms`);\n    console.log(`Maximum: ${results.responseTime.max.toFixed(2)}ms`);\n    \n    console.log('\\n✅ THRESHOLD VALIDATION');\n    console.log('-' .repeat(30));\n    console.log(`95th Percentile < ${CONFIG.thresholds.responseTime.p95}ms: ${results.thresholdsPassed.responseTime.p95 ? 'PASS' : 'FAIL'}`);\n    console.log(`99th Percentile < ${CONFIG.thresholds.responseTime.p99}ms: ${results.thresholdsPassed.responseTime.p99 ? 'PASS' : 'FAIL'}`);\n    console.log(`Error Rate < ${(CONFIG.thresholds.errorRate * 100)}%: ${results.thresholdsPassed.errorRate ? 'PASS' : 'FAIL'}`);\n    console.log(`Throughput > ${CONFIG.thresholds.throughput} req/s: ${results.thresholdsPassed.throughput ? 'PASS' : 'FAIL'}`);\n    \n    // Save detailed results to file\n    const reportPath = path.join(__dirname, '../logs', `load-test-${Date.now()}.json`);\n    try {\n      if (!fs.existsSync(path.dirname(reportPath))) {\n        fs.mkdirSync(path.dirname(reportPath), { recursive: true });\n      }\n      fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));\n      console.log(`\\n📄 Detailed report saved to: ${reportPath}`);\n    } catch (error) {\n      console.error('Failed to save report:', error.message);\n    }\n  }\n  \n  async sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  \n  cleanup() {\n    this.client.destroy();\n  }\n}\n\n// ============================================\n// CLI INTERFACE\n// ============================================\n\nasync function main() {\n  const coordinator = new LoadTestCoordinator(CONFIG);\n  \n  try {\n    // Run the load test\n    const results = await coordinator.runLoadTest();\n    \n    // Exit with appropriate code\n    const allThresholdsPassed = Object.values(results.thresholdsPassed)\n      .every(result => typeof result === 'boolean' ? result : Object.values(result).every(Boolean));\n    \n    process.exit(allThresholdsPassed ? 0 : 1);\n    \n  } catch (error) {\n    console.error('❌ Load test failed:', error);\n    process.exit(1);\n  } finally {\n    coordinator.cleanup();\n  }\n}\n\n// Handle graceful shutdown\nprocess.on('SIGINT', () => {\n  console.log('\\n🛑 Received SIGINT, shutting down gracefully...');\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('\\n🛑 Received SIGTERM, shutting down gracefully...');\n  process.exit(0);\n});\n\n// Run if called directly\nif (require.main === module) {\n  main();\n}\n\nmodule.exports = {\n  LoadTestClient,\n  VirtualUser,\n  LoadTestCoordinator,\n  CONFIG\n};"