/**\n * ESM Platform - Redis Caching Strategy\n * High-performance caching for 300+ concurrent users with session and query caching\n */\n\nimport { createClient, RedisClientType } from 'redis';\n\n// ============================================\n// REDIS CLIENT CONFIGURATION\n// ============================================\n\ninterface RedisConfig {\n  url?: string;\n  host?: string;\n  port?: number;\n  password?: string;\n  database?: number;\n  keyPrefix?: string;\n  connectTimeout?: number;\n  lazyConnect?: boolean;\n}\n\nclass RedisManager {\n  private client: RedisClientType | null = null;\n  private isConnected = false;\n  private config: RedisConfig;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 10;\n  private reconnectDelay = 1000; // Start with 1 second\n  \n  constructor(config: RedisConfig = {}) {\n    this.config = {\n      host: process.env.REDIS_HOST || 'localhost',\n      port: parseInt(process.env.REDIS_PORT || '6379'),\n      password: process.env.REDIS_PASSWORD,\n      database: parseInt(process.env.REDIS_DB || '0'),\n      keyPrefix: process.env.REDIS_KEY_PREFIX || 'esm:',\n      connectTimeout: 10000,\n      lazyConnect: true,\n      ...config\n    };\n  }\n  \n  async connect(): Promise<void> {\n    if (this.isConnected && this.client) {\n      return;\n    }\n    \n    try {\n      const redisUrl = this.config.url || \n        `redis://${this.config.password ? `:${this.config.password}@` : ''}${this.config.host}:${this.config.port}/${this.config.database}`;\n      \n      this.client = createClient({\n        url: redisUrl,\n        socket: {\n          connectTimeout: this.config.connectTimeout,\n          lazyConnect: this.config.lazyConnect,\n          reconnectStrategy: (retries) => {\n            if (retries >= this.maxReconnectAttempts) {\n              console.error('üî¥ Redis max reconnection attempts reached');\n              return false;\n            }\n            \n            const delay = Math.min(this.reconnectDelay * Math.pow(2, retries), 30000);\n            console.warn(`üü° Redis reconnecting in ${delay}ms (attempt ${retries + 1})`);\n            return delay;\n          }\n        },\n        ...(this.config.keyPrefix && {\n          prefix: this.config.keyPrefix\n        })\n      }) as RedisClientType;\n      \n      // Event handlers\n      this.client.on('connect', () => {\n        console.log('üü¢ Redis client connected');\n        this.reconnectAttempts = 0;\n      });\n      \n      this.client.on('ready', () => {\n        console.log('‚úÖ Redis client ready');\n        this.isConnected = true;\n      });\n      \n      this.client.on('error', (error) => {\n        console.error('üî¥ Redis client error:', error.message);\n        this.isConnected = false;\n      });\n      \n      this.client.on('end', () => {\n        console.log('üî¥ Redis client disconnected');\n        this.isConnected = false;\n      });\n      \n      this.client.on('reconnecting', () => {\n        console.log('üü° Redis client reconnecting...');\n        this.reconnectAttempts++;\n      });\n      \n      await this.client.connect();\n      \n    } catch (error) {\n      console.error('‚ùå Failed to connect to Redis:', error);\n      throw error;\n    }\n  }\n  \n  async disconnect(): Promise<void> {\n    if (this.client) {\n      await this.client.quit();\n      this.client = null;\n      this.isConnected = false;\n      console.log('üî¥ Redis client disconnected');\n    }\n  }\n  \n  getClient(): RedisClientType {\n    if (!this.client || !this.isConnected) {\n      throw new Error('Redis client is not connected');\n    }\n    return this.client;\n  }\n  \n  isReady(): boolean {\n    return this.isConnected && this.client !== null;\n  }\n  \n  async ping(): Promise<boolean> {\n    try {\n      if (!this.isReady()) {\n        await this.connect();\n      }\n      const result = await this.client!.ping();\n      return result === 'PONG';\n    } catch (error) {\n      console.error('‚ùå Redis ping failed:', error);\n      return false;\n    }\n  }\n}\n\nexport const redisManager = new RedisManager();\n\n// ============================================\n// CACHING UTILITIES\n// ============================================\n\ninterface CacheOptions {\n  ttl?: number;           // Time to live in seconds\n  prefix?: string;        // Key prefix\n  serialize?: boolean;    // Whether to JSON serialize/deserialize\n  compress?: boolean;     // Whether to compress data (future)\n}\n\nclass CacheService {\n  private defaultTTL = 300; // 5 minutes\n  \n  private getKey(key: string, prefix?: string): string {\n    return prefix ? `${prefix}:${key}` : key;\n  }\n  \n  async set<T>(key: string, value: T, options: CacheOptions = {}): Promise<boolean> {\n    try {\n      if (!redisManager.isReady()) {\n        await redisManager.connect();\n      }\n      \n      const client = redisManager.getClient();\n      const cacheKey = this.getKey(key, options.prefix);\n      const ttl = options.ttl || this.defaultTTL;\n      \n      let serializedValue: string;\n      \n      if (options.serialize !== false) {\n        serializedValue = JSON.stringify({\n          data: value,\n          timestamp: Date.now(),\n          type: typeof value\n        });\n      } else {\n        serializedValue = String(value);\n      }\n      \n      const result = await client.setEx(cacheKey, ttl, serializedValue);\n      return result === 'OK';\n      \n    } catch (error) {\n      console.error('‚ùå Cache set error:', error);\n      return false;\n    }\n  }\n  \n  async get<T>(key: string, options: CacheOptions = {}): Promise<T | null> {\n    try {\n      if (!redisManager.isReady()) {\n        await redisManager.connect();\n      }\n      \n      const client = redisManager.getClient();\n      const cacheKey = this.getKey(key, options.prefix);\n      \n      const value = await client.get(cacheKey);\n      \n      if (value === null) {\n        return null;\n      }\n      \n      if (options.serialize !== false) {\n        try {\n          const parsed = JSON.parse(value);\n          return parsed.data as T;\n        } catch (error) {\n          console.warn('‚ö†Ô∏è Cache deserialization error:', error);\n          return value as T;\n        }\n      }\n      \n      return value as T;\n      \n    } catch (error) {\n      console.error('‚ùå Cache get error:', error);\n      return null;\n    }\n  }\n  \n  async delete(key: string, options: CacheOptions = {}): Promise<boolean> {\n    try {\n      if (!redisManager.isReady()) {\n        await redisManager.connect();\n      }\n      \n      const client = redisManager.getClient();\n      const cacheKey = this.getKey(key, options.prefix);\n      \n      const result = await client.del(cacheKey);\n      return result > 0;\n      \n    } catch (error) {\n      console.error('‚ùå Cache delete error:', error);\n      return false;\n    }\n  }\n  \n  async exists(key: string, options: CacheOptions = {}): Promise<boolean> {\n    try {\n      if (!redisManager.isReady()) {\n        await redisManager.connect();\n      }\n      \n      const client = redisManager.getClient();\n      const cacheKey = this.getKey(key, options.prefix);\n      \n      const result = await client.exists(cacheKey);\n      return result === 1;\n      \n    } catch (error) {\n      console.error('‚ùå Cache exists error:', error);\n      return false;\n    }\n  }\n  \n  async expire(key: string, ttl: number, options: CacheOptions = {}): Promise<boolean> {\n    try {\n      if (!redisManager.isReady()) {\n        await redisManager.connect();\n      }\n      \n      const client = redisManager.getClient();\n      const cacheKey = this.getKey(key, options.prefix);\n      \n      const result = await client.expire(cacheKey, ttl);\n      return result === 1;\n      \n    } catch (error) {\n      console.error('‚ùå Cache expire error:', error);\n      return false;\n    }\n  }\n  \n  async ttl(key: string, options: CacheOptions = {}): Promise<number> {\n    try {\n      if (!redisManager.isReady()) {\n        await redisManager.connect();\n      }\n      \n      const client = redisManager.getClient();\n      const cacheKey = this.getKey(key, options.prefix);\n      \n      return await client.ttl(cacheKey);\n      \n    } catch (error) {\n      console.error('‚ùå Cache TTL error:', error);\n      return -2; // Key doesn't exist\n    }\n  }\n  \n  async clear(pattern: string = '*', options: CacheOptions = {}): Promise<number> {\n    try {\n      if (!redisManager.isReady()) {\n        await redisManager.connect();\n      }\n      \n      const client = redisManager.getClient();\n      const searchPattern = this.getKey(pattern, options.prefix);\n      \n      const keys = await client.keys(searchPattern);\n      \n      if (keys.length === 0) {\n        return 0;\n      }\n      \n      const result = await client.del(keys);\n      return result;\n      \n    } catch (error) {\n      console.error('‚ùå Cache clear error:', error);\n      return 0;\n    }\n  }\n}\n\nexport const cacheService = new CacheService();\n\n// ============================================\n// SESSION CACHING\n// ============================================\n\ninterface SessionData {\n  userId: string;\n  username: string;\n  email: string;\n  roles: string[];\n  permissions: Record<string, string[]>;\n  lastActivity: number;\n  loginTime: number;\n  ipAddress?: string;\n  userAgent?: string;\n}\n\nclass SessionCache {\n  private readonly prefix = 'session';\n  private readonly defaultTTL = 3600; // 1 hour\n  \n  async setSession(sessionId: string, sessionData: SessionData, ttl?: number): Promise<boolean> {\n    const data = {\n      ...sessionData,\n      lastActivity: Date.now()\n    };\n    \n    return await cacheService.set(sessionId, data, {\n      prefix: this.prefix,\n      ttl: ttl || this.defaultTTL\n    });\n  }\n  \n  async getSession(sessionId: string): Promise<SessionData | null> {\n    return await cacheService.get<SessionData>(sessionId, {\n      prefix: this.prefix\n    });\n  }\n  \n  async updateLastActivity(sessionId: string): Promise<boolean> {\n    const session = await this.getSession(sessionId);\n    if (!session) {\n      return false;\n    }\n    \n    session.lastActivity = Date.now();\n    return await this.setSession(sessionId, session);\n  }\n  \n  async deleteSession(sessionId: string): Promise<boolean> {\n    return await cacheService.delete(sessionId, {\n      prefix: this.prefix\n    });\n  }\n  \n  async extendSession(sessionId: string, ttl?: number): Promise<boolean> {\n    return await cacheService.expire(sessionId, ttl || this.defaultTTL, {\n      prefix: this.prefix\n    });\n  }\n  \n  async getUserSessions(userId: string): Promise<string[]> {\n    try {\n      if (!redisManager.isReady()) {\n        await redisManager.connect();\n      }\n      \n      const client = redisManager.getClient();\n      const pattern = `${this.prefix}:*`;\n      const keys = await client.keys(pattern);\n      \n      const userSessions: string[] = [];\n      \n      // Check each session to find ones belonging to the user\n      for (const key of keys) {\n        const sessionData = await cacheService.get<SessionData>(key.replace(`${this.prefix}:`, ''), {\n          prefix: this.prefix\n        });\n        \n        if (sessionData && sessionData.userId === userId) {\n          userSessions.push(key.replace(`${this.prefix}:`, ''));\n        }\n      }\n      \n      return userSessions;\n      \n    } catch (error) {\n      console.error('‚ùå Error getting user sessions:', error);\n      return [];\n    }\n  }\n  \n  async clearUserSessions(userId: string): Promise<number> {\n    const sessions = await this.getUserSessions(userId);\n    let cleared = 0;\n    \n    for (const sessionId of sessions) {\n      if (await this.deleteSession(sessionId)) {\n        cleared++;\n      }\n    }\n    \n    return cleared;\n  }\n}\n\nexport const sessionCache = new SessionCache();\n\n// ============================================\n// QUERY RESULT CACHING\n// ============================================\n\ninterface QueryCacheOptions extends CacheOptions {\n  invalidationTags?: string[]; // Tags for cache invalidation\n  refreshOnAccess?: boolean;   // Refresh TTL when accessed\n}\n\nclass QueryCache {\n  private readonly prefix = 'query';\n  private readonly tagPrefix = 'tag';\n  private readonly defaultTTL = 300; // 5 minutes\n  \n  async cacheQuery<T>(\n    queryKey: string,\n    queryFn: () => Promise<T>,\n    options: QueryCacheOptions = {}\n  ): Promise<T> {\n    // Try to get from cache first\n    const cached = await cacheService.get<T>(queryKey, {\n      prefix: this.prefix\n    });\n    \n    if (cached !== null) {\n      // Refresh TTL if requested\n      if (options.refreshOnAccess) {\n        await cacheService.expire(queryKey, options.ttl || this.defaultTTL, {\n          prefix: this.prefix\n        });\n      }\n      \n      return cached;\n    }\n    \n    // Execute query and cache result\n    const result = await queryFn();\n    \n    await this.setQueryCache(queryKey, result, options);\n    \n    return result;\n  }\n  \n  private async setQueryCache<T>(queryKey: string, data: T, options: QueryCacheOptions = {}): Promise<void> {\n    // Cache the query result\n    await cacheService.set(queryKey, data, {\n      prefix: this.prefix,\n      ttl: options.ttl || this.defaultTTL\n    });\n    \n    // Store invalidation tags if provided\n    if (options.invalidationTags && options.invalidationTags.length > 0) {\n      for (const tag of options.invalidationTags) {\n        await this.addQueryToTag(tag, queryKey);\n      }\n    }\n  }\n  \n  private async addQueryToTag(tag: string, queryKey: string): Promise<void> {\n    try {\n      if (!redisManager.isReady()) {\n        await redisManager.connect();\n      }\n      \n      const client = redisManager.getClient();\n      const tagKey = `${this.tagPrefix}:${tag}`;\n      \n      await client.sAdd(tagKey, queryKey);\n      await client.expire(tagKey, 3600); // Tags expire after 1 hour\n      \n    } catch (error) {\n      console.error('‚ùå Error adding query to tag:', error);\n    }\n  }\n  \n  async invalidateByTags(tags: string[]): Promise<number> {\n    let invalidated = 0;\n    \n    try {\n      if (!redisManager.isReady()) {\n        await redisManager.connect();\n      }\n      \n      const client = redisManager.getClient();\n      \n      for (const tag of tags) {\n        const tagKey = `${this.tagPrefix}:${tag}`;\n        const queryKeys = await client.sMembers(tagKey);\n        \n        // Delete all queries associated with this tag\n        for (const queryKey of queryKeys) {\n          if (await cacheService.delete(queryKey, { prefix: this.prefix })) {\n            invalidated++;\n          }\n        }\n        \n        // Delete the tag set\n        await client.del(tagKey);\n      }\n      \n    } catch (error) {\n      console.error('‚ùå Error invalidating by tags:', error);\n    }\n    \n    return invalidated;\n  }\n  \n  async invalidateQuery(queryKey: string): Promise<boolean> {\n    return await cacheService.delete(queryKey, {\n      prefix: this.prefix\n    });\n  }\n  \n  async clearAllQueries(): Promise<number> {\n    return await cacheService.clear('*', {\n      prefix: this.prefix\n    });\n  }\n}\n\nexport const queryCache = new QueryCache();\n\n// ============================================\n// CACHE HEALTH MONITORING\n// ============================================\n\nexport interface CacheHealthStatus {\n  connected: boolean;\n  latency?: number;\n  memory?: {\n    used: number;\n    peak: number;\n    total: number;\n  };\n  stats?: {\n    hits: number;\n    misses: number;\n    keys: number;\n    expired: number;\n  };\n  error?: string;\n}\n\nexport async function checkCacheHealth(): Promise<CacheHealthStatus> {\n  try {\n    const startTime = Date.now();\n    \n    // Test connection\n    const connected = await redisManager.ping();\n    const latency = Date.now() - startTime;\n    \n    if (!connected) {\n      return {\n        connected: false,\n        error: 'Redis connection failed'\n      };\n    }\n    \n    const client = redisManager.getClient();\n    \n    // Get memory info\n    const memoryInfo = await client.memory('USAGE');\n    const info = await client.info('stats');\n    \n    // Parse stats\n    const stats = {\n      hits: 0,\n      misses: 0,\n      keys: 0,\n      expired: 0\n    };\n    \n    const lines = info.split('\\r\\n');\n    for (const line of lines) {\n      if (line.startsWith('keyspace_hits:')) {\n        stats.hits = parseInt(line.split(':')[1]);\n      } else if (line.startsWith('keyspace_misses:')) {\n        stats.misses = parseInt(line.split(':')[1]);\n      } else if (line.startsWith('expired_keys:')) {\n        stats.expired = parseInt(line.split(':')[1]);\n      }\n    }\n    \n    // Get key count\n    const dbInfo = await client.info('keyspace');\n    const dbLine = dbInfo.split('\\r\\n').find(line => line.startsWith('db0:'));\n    if (dbLine) {\n      const keyMatch = dbLine.match(/keys=([0-9]+)/);\n      if (keyMatch) {\n        stats.keys = parseInt(keyMatch[1]);\n      }\n    }\n    \n    return {\n      connected: true,\n      latency,\n      memory: {\n        used: memoryInfo || 0,\n        peak: 0, // Would need MEMORY STATS for this\n        total: 0  // Would need system info\n      },\n      stats\n    };\n    \n  } catch (error) {\n    return {\n      connected: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n\n// ============================================\n// INITIALIZATION AND CLEANUP\n// ============================================\n\nexport async function initializeCache(): Promise<void> {\n  try {\n    console.log('üîÑ Initializing Redis cache...');\n    await redisManager.connect();\n    \n    const health = await checkCacheHealth();\n    if (health.connected) {\n      console.log(`‚úÖ Redis cache ready (latency: ${health.latency}ms)`);\n    } else {\n      console.warn(`‚ö†Ô∏è Redis cache health check failed: ${health.error}`);\n    }\n    \n  } catch (error) {\n    console.error('‚ùå Failed to initialize Redis cache:', error);\n    // Don't throw - allow application to start without Redis\n  }\n}\n\nexport async function shutdownCache(): Promise<void> {\n  try {\n    await redisManager.disconnect();\n    console.log('üî¥ Redis cache shut down');\n  } catch (error) {\n    console.error('‚ùå Error shutting down Redis cache:', error);\n  }\n}\n\n// Auto-initialize in Node.js environment\nif (typeof window === 'undefined' && process.env.NODE_ENV !== 'test') {\n  // Initialize after a short delay to allow other systems to start\n  setTimeout(() => {\n    initializeCache().catch(console.error);\n  }, 1000);\n  \n  // Graceful shutdown\n  process.on('SIGINT', async () => {\n    await shutdownCache();\n  });\n  \n  process.on('SIGTERM', async () => {\n    await shutdownCache();\n  });\n}\n\nexport default {\n  redisManager,\n  cacheService,\n  sessionCache,\n  queryCache,\n  checkCacheHealth,\n  initializeCache,\n  shutdownCache\n};"