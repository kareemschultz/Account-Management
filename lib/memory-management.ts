/**
 * ESM Platform - Memory Management Optimization
 * Prevents memory leaks and optimizes garbage collection for 300+ concurrent users
 */

import { useEffect, useRef, useCallback } from 'react';

// ============================================
// MEMORY LEAK PREVENTION
// ============================================

/**
 * Hook to automatically cleanup event listeners and prevent memory leaks
 */
export function useEventListener<T extends Event>(
  eventName: string,
  handler: (event: T) => void,
  element?: Element | Window | null,
  options?: AddEventListenerOptions
) {
  const savedHandler = useRef<(event: T) => void>();
  
  useEffect(() => {
    savedHandler.current = handler;
  }, [handler]);
  
  useEffect(() => {
    const targetElement = element || window;
    if (!targetElement?.addEventListener) return;
    
    const eventListener = (event: Event) => savedHandler.current?.(event as T);
    
    targetElement.addEventListener(eventName, eventListener, options);
    
    return () => {
      targetElement.removeEventListener(eventName, eventListener, options);
    };
  }, [eventName, element, options]);
}\n\n/**\n * Hook for cleanup of intervals and timeouts\n */\nexport function useInterval(callback: () => void, delay: number | null) {\n  const savedCallback = useRef<() => void>();\n  \n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n  \n  useEffect(() => {\n    if (delay === null) return;\n    \n    const id = setInterval(() => savedCallback.current?.(), delay);\n    return () => clearInterval(id);\n  }, [delay]);\n}\n\nexport function useTimeout(callback: () => void, delay: number | null) {\n  const savedCallback = useRef<() => void>();\n  \n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n  \n  useEffect(() => {\n    if (delay === null) return;\n    \n    const id = setTimeout(() => savedCallback.current?.(), delay);\n    return () => clearTimeout(id);\n  }, [delay]);\n}\n\n/**\n * Hook for cleanup of AbortController instances\n */\nexport function useAbortController() {\n  const controllerRef = useRef<AbortController>();\n  \n  const getController = useCallback(() => {\n    if (!controllerRef.current || controllerRef.current.signal.aborted) {\n      controllerRef.current = new AbortController();\n    }\n    return controllerRef.current;\n  }, []);\n  \n  const abort = useCallback(() => {\n    controllerRef.current?.abort();\n  }, []);\n  \n  useEffect(() => {\n    return () => {\n      controllerRef.current?.abort();\n    };\n  }, []);\n  \n  return { getController, abort };\n}\n\n// ============================================\n// MEMORY MONITORING\n// ============================================\n\ninterface MemoryStats {\n  usedJSHeapSize: number;\n  totalJSHeapSize: number;\n  jsHeapSizeLimit: number;\n  timestamp: number;\n}\n\nclass MemoryMonitor {\n  private stats: MemoryStats[] = [];\n  private maxStatsHistory = 100;\n  private warningThreshold = 0.8; // 80% of heap limit\n  private criticalThreshold = 0.9; // 90% of heap limit\n  \n  private getMemoryInfo(): MemoryStats | null {\n    if ('memory' in performance && (performance as any).memory) {\n      const memory = (performance as any).memory;\n      return {\n        usedJSHeapSize: memory.usedJSHeapSize,\n        totalJSHeapSize: memory.totalJSHeapSize,\n        jsHeapSizeLimit: memory.jsHeapSizeLimit,\n        timestamp: Date.now()\n      };\n    }\n    return null;\n  }\n  \n  recordMemoryUsage(): MemoryStats | null {\n    const memoryInfo = this.getMemoryInfo();\n    if (!memoryInfo) return null;\n    \n    this.stats.push(memoryInfo);\n    \n    // Keep only recent stats\n    if (this.stats.length > this.maxStatsHistory) {\n      this.stats = this.stats.slice(-this.maxStatsHistory);\n    }\n    \n    // Check for memory warnings\n    const usageRatio = memoryInfo.usedJSHeapSize / memoryInfo.jsHeapSizeLimit;\n    \n    if (usageRatio > this.criticalThreshold) {\n      console.error('üö® Critical memory usage detected:', {\n        used: `${Math.round(memoryInfo.usedJSHeapSize / 1024 / 1024)}MB`,\n        limit: `${Math.round(memoryInfo.jsHeapSizeLimit / 1024 / 1024)}MB`,\n        percentage: `${Math.round(usageRatio * 100)}%`\n      });\n      this.triggerGarbageCollection();\n    } else if (usageRatio > this.warningThreshold) {\n      console.warn('‚ö†Ô∏è High memory usage detected:', {\n        used: `${Math.round(memoryInfo.usedJSHeapSize / 1024 / 1024)}MB`,\n        limit: `${Math.round(memoryInfo.jsHeapSizeLimit / 1024 / 1024)}MB`,\n        percentage: `${Math.round(usageRatio * 100)}%`\n      });\n    }\n    \n    return memoryInfo;\n  }\n  \n  private triggerGarbageCollection(): void {\n    // Force garbage collection if available (Chrome DevTools)\n    if ('gc' in window && typeof (window as any).gc === 'function') {\n      console.log('üóëÔ∏è Triggering garbage collection...');\n      (window as any).gc();\n    }\n    \n    // Alternative: Create memory pressure to encourage GC\n    this.createMemoryPressure();\n  }\n  \n  private createMemoryPressure(): void {\n    // Create temporary memory pressure to encourage garbage collection\n    const tempArrays = [];\n    try {\n      for (let i = 0; i < 100; i++) {\n        tempArrays.push(new Array(10000).fill(Math.random()));\n      }\n    } catch (e) {\n      // Expected if we run out of memory\n    } finally {\n      // Clear the arrays to allow GC\n      tempArrays.length = 0;\n    }\n  }\n  \n  getMemoryTrend(): {\n    current: MemoryStats | null;\n    trend: 'increasing' | 'decreasing' | 'stable';\n    averageUsage: number;\n  } {\n    if (this.stats.length < 2) {\n      return {\n        current: this.stats[0] || null,\n        trend: 'stable',\n        averageUsage: 0\n      };\n    }\n    \n    const recent = this.stats.slice(-10); // Last 10 measurements\n    const current = recent[recent.length - 1];\n    const previous = recent[0];\n    \n    const usageChange = current.usedJSHeapSize - previous.usedJSHeapSize;\n    const trend = Math.abs(usageChange) < 1024 * 1024 // 1MB threshold\n      ? 'stable'\n      : usageChange > 0\n        ? 'increasing'\n        : 'decreasing';\n    \n    const averageUsage = recent.reduce((sum, stat) => sum + stat.usedJSHeapSize, 0) / recent.length;\n    \n    return { current, trend, averageUsage };\n  }\n  \n  startMonitoring(intervalMs: number = 30000): () => void {\n    const interval = setInterval(() => {\n      this.recordMemoryUsage();\n    }, intervalMs);\n    \n    return () => clearInterval(interval);\n  }\n}\n\nexport const memoryMonitor = new MemoryMonitor();\n\n// ============================================\n// OBJECT POOL FOR MEMORY EFFICIENCY\n// ============================================\n\nclass ObjectPool<T> {\n  private pool: T[] = [];\n  private createFn: () => T;\n  private resetFn: (obj: T) => void;\n  private maxSize: number;\n  \n  constructor(\n    createFn: () => T,\n    resetFn: (obj: T) => void,\n    maxSize: number = 100\n  ) {\n    this.createFn = createFn;\n    this.resetFn = resetFn;\n    this.maxSize = maxSize;\n  }\n  \n  get(): T {\n    const obj = this.pool.pop();\n    if (obj) {\n      this.resetFn(obj);\n      return obj;\n    }\n    return this.createFn();\n  }\n  \n  release(obj: T): void {\n    if (this.pool.length < this.maxSize) {\n      this.pool.push(obj);\n    }\n  }\n  \n  clear(): void {\n    this.pool.length = 0;\n  }\n  \n  get size(): number {\n    return this.pool.length;\n  }\n}\n\n// Commonly used object pools\nexport const arrayPool = new ObjectPool(\n  () => [],\n  (arr) => { arr.length = 0; },\n  50\n);\n\nexport const objectPool = new ObjectPool(\n  () => ({}),\n  (obj) => {\n    for (const key in obj) {\n      delete obj[key];\n    }\n  },\n  50\n);\n\n// ============================================\n// WEAK REFERENCES FOR CACHE MANAGEMENT\n// ============================================\n\nclass WeakCache<K extends object, V> {\n  private cache = new WeakMap<K, V>();\n  private keyRefs = new Set<WeakRef<K>>();\n  private registry = new FinalizationRegistry((heldValue: any) => {\n    // Cleanup when keys are garbage collected\n    console.log('üßπ WeakCache key was garbage collected');\n  });\n  \n  set(key: K, value: V): void {\n    this.cache.set(key, value);\n    const weakRef = new WeakRef(key);\n    this.keyRefs.add(weakRef);\n    this.registry.register(key, null);\n  }\n  \n  get(key: K): V | undefined {\n    return this.cache.get(key);\n  }\n  \n  has(key: K): boolean {\n    return this.cache.has(key);\n  }\n  \n  delete(key: K): boolean {\n    return this.cache.delete(key);\n  }\n  \n  cleanup(): void {\n    // Remove dead weak references\n    const aliveRefs = new Set<WeakRef<K>>();\n    for (const ref of this.keyRefs) {\n      if (ref.deref()) {\n        aliveRefs.add(ref);\n      }\n    }\n    this.keyRefs = aliveRefs;\n  }\n  \n  get approximateSize(): number {\n    return this.keyRefs.size;\n  }\n}\n\nexport const componentCache = new WeakCache<object, any>();\n\n// ============================================\n// MEMORY-EFFICIENT HOOKS\n// ============================================\n\n/**\n * Hook that automatically cleans up refs when component unmounts\n */\nexport function useManagedRef<T>(initialValue: T | null = null): React.MutableRefObject<T | null> {\n  const ref = useRef<T | null>(initialValue);\n  \n  useEffect(() => {\n    return () => {\n      ref.current = null;\n    };\n  }, []);\n  \n  return ref;\n}\n\n/**\n * Hook for managing large datasets with automatic cleanup\n */\nexport function useManagedData<T>(data: T[], maxSize: number = 1000): T[] {\n  const [managedData, setManagedData] = useState<T[]>([]);\n  \n  useEffect(() => {\n    if (data.length <= maxSize) {\n      setManagedData(data);\n    } else {\n      // Keep only the most recent items\n      setManagedData(data.slice(-maxSize));\n      console.warn(`üóÇÔ∏è Dataset truncated from ${data.length} to ${maxSize} items for memory management`);\n    }\n  }, [data, maxSize]);\n  \n  return managedData;\n}\n\n/**\n * Hook for memory-efficient component state\n */\nexport function useMemoryEfficientState<T>(\n  initialState: T,\n  cleanup?: (state: T) => void\n): [T, React.Dispatch<React.SetStateAction<T>>] {\n  const [state, setState] = useState<T>(initialState);\n  \n  useEffect(() => {\n    return () => {\n      if (cleanup && state) {\n        cleanup(state);\n      }\n    };\n  }, []);\n  \n  return [state, setState];\n}\n\n// ============================================\n// MEMORY OPTIMIZATION UTILITIES\n// ============================================\n\n/**\n * Debounce function with automatic cleanup\n */\nexport function createManagedDebounce<T extends (...args: any[]) => void>(\n  func: T,\n  delay: number\n): T & { cancel: () => void; cleanup: () => void } {\n  let timeoutId: NodeJS.Timeout | null = null;\n  \n  const debouncedFunc = ((...args: Parameters<T>) => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    \n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n      timeoutId = null;\n    }, delay);\n  }) as T & { cancel: () => void; cleanup: () => void };\n  \n  debouncedFunc.cancel = () => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n  };\n  \n  debouncedFunc.cleanup = debouncedFunc.cancel;\n  \n  return debouncedFunc;\n}\n\n/**\n * Memory-efficient deep clone for large objects\n */\nexport function efficientDeepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  // Use structured cloning if available (modern browsers)\n  if (typeof structuredClone === 'function') {\n    try {\n      return structuredClone(obj);\n    } catch (e) {\n      // Fall back to JSON method\n    }\n  }\n  \n  // JSON-based cloning (fastest for plain objects)\n  try {\n    return JSON.parse(JSON.stringify(obj));\n  } catch (e) {\n    // Fallback to manual cloning\n    if (Array.isArray(obj)) {\n      return obj.map(efficientDeepClone) as unknown as T;\n    }\n    \n    const cloned = {} as T;\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        (cloned as any)[key] = efficientDeepClone((obj as any)[key]);\n      }\n    }\n    return cloned;\n  }\n}\n\n/**\n * Start memory monitoring and cleanup\n */\nexport function startMemoryManagement(options: {\n  monitoringInterval?: number;\n  cleanupInterval?: number;\n} = {}): () => void {\n  const { monitoringInterval = 30000, cleanupInterval = 300000 } = options;\n  \n  // Start memory monitoring\n  const stopMonitoring = memoryMonitor.startMonitoring(monitoringInterval);\n  \n  // Start periodic cleanup\n  const cleanupInterval = setInterval(() => {\n    // Cleanup weak caches\n    componentCache.cleanup();\n    \n    // Clear object pools if they're getting too large\n    if (arrayPool.size > 25) {\n      arrayPool.clear();\n    }\n    if (objectPool.size > 25) {\n      objectPool.clear();\n    }\n    \n    console.log('üßπ Memory management cleanup completed');\n  }, cleanupInterval);\n  \n  return () => {\n    stopMonitoring();\n    clearInterval(cleanupInterval);\n  };\n}\n\n// Auto-start memory management in browser environment\nif (typeof window !== 'undefined') {\n  let cleanup: (() => void) | null = null;\n  \n  // Start after initial page load\n  window.addEventListener('load', () => {\n    cleanup = startMemoryManagement();\n  });\n  \n  // Cleanup on page unload\n  window.addEventListener('beforeunload', () => {\n    cleanup?.();\n  });\n}\n\nexport default {\n  useEventListener,\n  useInterval,\n  useTimeout,\n  useAbortController,\n  memoryMonitor,\n  ObjectPool,\n  arrayPool,\n  objectPool,\n  WeakCache,\n  componentCache,\n  useManagedRef,\n  useManagedData,\n  useMemoryEfficientState,\n  createManagedDebounce,\n  efficientDeepClone,\n  startMemoryManagement\n};